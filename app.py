{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "d653113c-6c9c-45b5-9b34-46e5df945383",
   "metadata": {},
   "source": [
    "# Backend Development\n",
    "## Set up Flask server for API handling"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "e746d7f5-5f82-4665-b9b5-11b3e58bc07d",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      " * Serving Flask app '__main__'\n",
      " * Debug mode: on\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.\n",
      " * Running on http://127.0.0.1:5000\n",
      "Press CTRL+C to quit\n"
     ]
    },
    {
     "ename": "ImportError",
     "evalue": "cannot import name 'EVENT_TYPE_OPENED' from 'watchdog.events' (C:\\ProgramData\\anaconda3\\Lib\\site-packages\\watchdog\\events.py)",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mImportError\u001b[0m                               Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[1], line 111\u001b[0m\n\u001b[0;32m    108\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m jsonify(forecast)\n\u001b[0;32m    110\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;18m__name__\u001b[39m \u001b[38;5;241m==\u001b[39m \u001b[38;5;124m'\u001b[39m\u001b[38;5;124m__main__\u001b[39m\u001b[38;5;124m'\u001b[39m:\n\u001b[1;32m--> 111\u001b[0m     app\u001b[38;5;241m.\u001b[39mrun(debug\u001b[38;5;241m=\u001b[39m\u001b[38;5;28;01mTrue\u001b[39;00m)\n",
      "File \u001b[1;32mC:\\ProgramData\\anaconda3\\Lib\\site-packages\\flask\\app.py:1191\u001b[0m, in \u001b[0;36mFlask.run\u001b[1;34m(self, host, port, debug, load_dotenv, **options)\u001b[0m\n\u001b[0;32m   1188\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mwerkzeug\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mserving\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m run_simple\n\u001b[0;32m   1190\u001b[0m \u001b[38;5;28;01mtry\u001b[39;00m:\n\u001b[1;32m-> 1191\u001b[0m     run_simple(t\u001b[38;5;241m.\u001b[39mcast(\u001b[38;5;28mstr\u001b[39m, host), port, \u001b[38;5;28mself\u001b[39m, \u001b[38;5;241m*\u001b[39m\u001b[38;5;241m*\u001b[39moptions)\n\u001b[0;32m   1192\u001b[0m \u001b[38;5;28;01mfinally\u001b[39;00m:\n\u001b[0;32m   1193\u001b[0m     \u001b[38;5;66;03m# reset the first request information if the development server\u001b[39;00m\n\u001b[0;32m   1194\u001b[0m     \u001b[38;5;66;03m# reset normally.  This makes it possible to restart the server\u001b[39;00m\n\u001b[0;32m   1195\u001b[0m     \u001b[38;5;66;03m# without reloader and that stuff from an interactive shell.\u001b[39;00m\n\u001b[0;32m   1196\u001b[0m     \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_got_first_request \u001b[38;5;241m=\u001b[39m \u001b[38;5;28;01mFalse\u001b[39;00m\n",
      "File \u001b[1;32m~\\AppData\\Roaming\\Python\\Python311\\site-packages\\werkzeug\\serving.py:1106\u001b[0m, in \u001b[0;36mrun_simple\u001b[1;34m(hostname, port, application, use_reloader, use_debugger, use_evalex, extra_files, exclude_patterns, reloader_interval, reloader_type, threaded, processes, request_handler, static_files, passthrough_errors, ssl_context)\u001b[0m\n\u001b[0;32m   1103\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01m_reloader\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m run_with_reloader\n\u001b[0;32m   1105\u001b[0m \u001b[38;5;28;01mtry\u001b[39;00m:\n\u001b[1;32m-> 1106\u001b[0m     run_with_reloader(\n\u001b[0;32m   1107\u001b[0m         srv\u001b[38;5;241m.\u001b[39mserve_forever,\n\u001b[0;32m   1108\u001b[0m         extra_files\u001b[38;5;241m=\u001b[39mextra_files,\n\u001b[0;32m   1109\u001b[0m         exclude_patterns\u001b[38;5;241m=\u001b[39mexclude_patterns,\n\u001b[0;32m   1110\u001b[0m         interval\u001b[38;5;241m=\u001b[39mreloader_interval,\n\u001b[0;32m   1111\u001b[0m         reloader_type\u001b[38;5;241m=\u001b[39mreloader_type,\n\u001b[0;32m   1112\u001b[0m     )\n\u001b[0;32m   1113\u001b[0m \u001b[38;5;28;01mfinally\u001b[39;00m:\n\u001b[0;32m   1114\u001b[0m     srv\u001b[38;5;241m.\u001b[39mserver_close()\n",
      "File \u001b[1;32m~\\AppData\\Roaming\\Python\\Python311\\site-packages\\werkzeug\\_reloader.py:442\u001b[0m, in \u001b[0;36mrun_with_reloader\u001b[1;34m(main_func, extra_files, exclude_patterns, interval, reloader_type)\u001b[0m\n\u001b[0;32m    439\u001b[0m \u001b[38;5;28;01mimport\u001b[39;00m \u001b[38;5;21;01msignal\u001b[39;00m\n\u001b[0;32m    441\u001b[0m signal\u001b[38;5;241m.\u001b[39msignal(signal\u001b[38;5;241m.\u001b[39mSIGTERM, \u001b[38;5;28;01mlambda\u001b[39;00m \u001b[38;5;241m*\u001b[39margs: sys\u001b[38;5;241m.\u001b[39mexit(\u001b[38;5;241m0\u001b[39m))\n\u001b[1;32m--> 442\u001b[0m reloader \u001b[38;5;241m=\u001b[39m reloader_loops[reloader_type](\n\u001b[0;32m    443\u001b[0m     extra_files\u001b[38;5;241m=\u001b[39mextra_files, exclude_patterns\u001b[38;5;241m=\u001b[39mexclude_patterns, interval\u001b[38;5;241m=\u001b[39minterval\n\u001b[0;32m    444\u001b[0m )\n\u001b[0;32m    446\u001b[0m \u001b[38;5;28;01mtry\u001b[39;00m:\n\u001b[0;32m    447\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m os\u001b[38;5;241m.\u001b[39menviron\u001b[38;5;241m.\u001b[39mget(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mWERKZEUG_RUN_MAIN\u001b[39m\u001b[38;5;124m\"\u001b[39m) \u001b[38;5;241m==\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mtrue\u001b[39m\u001b[38;5;124m\"\u001b[39m:\n",
      "File \u001b[1;32m~\\AppData\\Roaming\\Python\\Python311\\site-packages\\werkzeug\\_reloader.py:315\u001b[0m, in \u001b[0;36mWatchdogReloaderLoop.__init__\u001b[1;34m(self, *args, **kwargs)\u001b[0m\n\u001b[0;32m    314\u001b[0m \u001b[38;5;28;01mdef\u001b[39;00m \u001b[38;5;21m__init__\u001b[39m(\u001b[38;5;28mself\u001b[39m, \u001b[38;5;241m*\u001b[39margs: t\u001b[38;5;241m.\u001b[39mAny, \u001b[38;5;241m*\u001b[39m\u001b[38;5;241m*\u001b[39mkwargs: t\u001b[38;5;241m.\u001b[39mAny) \u001b[38;5;241m-\u001b[39m\u001b[38;5;241m>\u001b[39m \u001b[38;5;28;01mNone\u001b[39;00m:\n\u001b[1;32m--> 315\u001b[0m     \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mwatchdog\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mevents\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m EVENT_TYPE_OPENED\n\u001b[0;32m    316\u001b[0m     \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mwatchdog\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mevents\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m FileModifiedEvent\n\u001b[0;32m    317\u001b[0m     \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mwatchdog\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mevents\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m PatternMatchingEventHandler\n",
      "\u001b[1;31mImportError\u001b[0m: cannot import name 'EVENT_TYPE_OPENED' from 'watchdog.events' (C:\\ProgramData\\anaconda3\\Lib\\site-packages\\watchdog\\events.py)"
     ]
    }
   ],
   "source": [
    "from flask import Flask, request, jsonify\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "from statsmodels.tsa.arima.model import ARIMA\n",
    "import tensorflow as tf\n",
    "from tensorflow.keras.models import Sequential\n",
    "from tensorflow.keras.layers import Dense, LSTM\n",
    "from sklearn.preprocessing import MinMaxScaler\n",
    "\n",
    "app = Flask(__name__)\n",
    "\n",
    "@app.route('/forecast', methods=['POST'])\n",
    "def forecast():\n",
    "    data = request.get_json()\n",
    "    model_type = data['model_type']\n",
    "    steps = data['steps']\n",
    "\n",
    "    if model_type == 'arima':\n",
    "        sp500 = pd.read_csv('processed_sp500.csv', index_col='Date', parse_dates=True)\n",
    "        arima_order = (5, 1, 0)\n",
    "        model_fit = ARIMA(sp500['S&P500'].dropna(), order=arima_order).fit()\n",
    "        forecast = model_fit.forecast(steps=steps).tolist()\n",
    "\n",
    "    elif model_type == 'lstm':\n",
    "        aep_hourly = pd.read_csv('processed_aep_hourly.csv', index_col='Datetime', parse_dates=True)\n",
    "        scaler = MinMaxScaler()\n",
    "        scaled_data = scaler.fit_transform(aep_hourly[['AEP_MW']])\n",
    "\n",
    "        def create_dataset(data, time_step=1):\n",
    "            X, Y = [], []\n",
    "            for i in range(len(data) - time_step - 1):\n",
    "                a = data[i:(i + time_step), 0]\n",
    "                X.append(a)\n",
    "                Y.append(data[i + time_step, 0])\n",
    "            return np.array(X), np.array(Y)\n",
    "\n",
    "        time_step = 24\n",
    "        X, Y = create_dataset(scaled_data, time_step)\n",
    "\n",
    "        train_size = int(len(X) * 0.8)\n",
    "        test_size = len(X) - train_size\n",
    "        X_train, X_test = X[0:train_size], X[train_size:len(X)]\n",
    "        Y_train, Y_test = Y[0:train_size], Y[train_size:len(Y)]\n",
    "\n",
    "        X_train = X_train.reshape(X_train.shape[0], X_train.shape[1], 1)\n",
    "        X_test = X_test.reshape(X_test.shape[0], X_test.shape[1], 1)\n",
    "\n",
    "        model = Sequential()\n",
    "        model.add(LSTM(50, return_sequences=True, input_shape=(time_step, 1)))\n",
    "        model.add(LSTM(50, return_sequences=False))\n",
    "        model.add(Dense(25))\n",
    "        model.add(Dense(1))\n",
    "\n",
    "        model.compile(optimizer='adam', loss='mean_squared_error')\n",
    "        model.fit(X_train, Y_train, batch_size=1, epochs=1)\n",
    "\n",
    "        test_predict = model.predict(X_test)\n",
    "        test_predict = scaler.inverse_transform(test_predict)\n",
    "        forecast = test_predict[-steps:].tolist()\n",
    "\n",
    "    elif model_type == 'hybrid':\n",
    "        aep_hourly = pd.read_csv('processed_aep_hourly.csv', index_col='Datetime', parse_dates=True)\n",
    "\n",
    "        arima_order = (5, 1, 0)\n",
    "        arima_model_fit = ARIMA(aep_hourly['AEP_MW'].dropna(), order=arima_order).fit()\n",
    "        arima_forecast = arima_model_fit.forecast(steps=len(aep_hourly))\n",
    "\n",
    "        scaler = MinMaxScaler()\n",
    "        scaled_data = scaler.fit_transform(aep_hourly[['AEP_MW']])\n",
    "\n",
    "        def create_dataset(data, time_step=1):\n",
    "            X, Y = [], []\n",
    "            for i in range(len(data) - time_step - 1):\n",
    "                a = data[i:(i + time_step), 0]\n",
    "                X.append(a)\n",
    "                Y.append(data[i + time_step, 0])\n",
    "            return np.array(X), np.array(Y)\n",
    "\n",
    "        time_step = 24\n",
    "        X, Y = create_dataset(scaled_data, time_step)\n",
    "\n",
    "        train_size = int(len(X) * 0.8)\n",
    "        test_size = len(X) - train_size\n",
    "        X_train, X_test = X[0:train_size], X[train_size:len(X)]\n",
    "        Y_train, Y_test = Y[0:train_size], Y[train_size:len(Y)]\n",
    "\n",
    "        X_train = X_train.reshape(X_train.shape[0], X_train.shape[1], 1)\n",
    "        X_test = X_test.reshape(X_test.shape[0], X_test.shape[1], 1)\n",
    "\n",
    "        model = Sequential()\n",
    "        model.add(LSTM(50, return_sequences=True, input_shape=(time_step, 1)))\n",
    "        model.add(LSTM(50, return_sequences=False))\n",
    "        model.add(Dense(25))\n",
    "        model.add(Dense(1))\n",
    "\n",
    "        model.compile(optimizer='adam', loss='mean_squared_error')\n",
    "        model.fit(X_train, Y_train, batch_size=1, epochs=1)\n",
    "\n",
    "        test_predict = model.predict(X_test)\n",
    "        test_predict = scaler.inverse_transform(test_predict)\n",
    "\n",
    "        def hybrid_model(arima_pred, ann_pred, alpha=0.5):\n",
    "            return alpha * arima_pred + (1 - alpha) * ann_pred\n",
    "\n",
    "        hybrid_forecast = hybrid_model(arima_forecast[-test_size:], test_predict)\n",
    "        forecast = hybrid_forecast[-steps:].tolist()\n",
    "\n",
    "    return jsonify(forecast)\n",
    "\n",
    "if __name__ == '__main__':\n",
    "    app.run(debug=True)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fec363a4-8ef5-43dc-8eb1-459afaddeee2",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
